local F={}do local f=function()local I={}local j={}function I.traverse(k,K)if type(k)~='table'or K.visited[k]then return end;K.visited[k]=true;local l=j[k.AstType]if l then l(k,K)end;for L,m in pairs(k)do I.traverse(m,K)end end;function j.MemberExpr(k,K)local l=k.Ident.Data;if l then k.Ident.Data=K.getMangledName(l)end end;function j.ConstructorExpr(k,K)if not k.EntryList then return end;for l,L in ipairs(k.EntryList)do if L.Type=='KeyString'then local m=L.Key;L.Key=K.getMangledName(m)elseif L.Type=='Key'and L.Key.AstType=='StringExpr'then K.mangleStringNode(L.Key)end end end;function j.IndexExpr(k,K)if k.Index and k.Index.AstType=='StringExpr'then K.mangleStringNode(k.Index)end end;local function J(k,K)local l={nameMap={},nextNameId=0,visited=setmetatable({},{__mode="k"})}function l.generateNextName()local L=l.nextNameId;local m=""repeat m=string.char(string.byte('a')+(L%26))..m;L=math.floor(L/26)-1 until L<0;l.nextNameId=l.nextNameId+1;return m end;function l.getMangledName(L)if L:sub(1,2)=="__"then return L end;if not K and L:sub(1,1)~="_"then return L end;if K and L:sub(1,1)=="_"then return L:sub(2)end;if not l.nameMap[L]then l.nameMap[L]=l.generateNextName()end;return l.nameMap[L]end;function l.mangleStringNode(L)local m=L.Value.Data;local M=m:sub(1,1)if M=="'"or M=='"'then local n=m:sub(2,-2)local N=l.getMangledName(n)L.Value.Data=M..N..M;l.visited[L.Value]=true end end;I.traverse(k,l)return k end;return J end;F[3]=function()local I=f()F[3]=function()return I end;return I end end;do local f=function()local function I(l)for L,m in pairs(l)do l[m]=true end;return l end;local function j(l)local L=0;for m in pairs(l)do L=L+1 end;return L end;local function J(l,L)if l.Print then return l.Print()end;L=L or 0;local m=(j(l)>1)local M=string.rep('    ',L+1)local n="{".. (m and'\n'or'')for N,o in pairs(l)do if type(o)~='function'then n=n.. (m and M or'')if type(N)=='number'then elseif type(N)=='string'and N:match("^[A-Za-z_][A-Za-z0-9_]*$")then n=n..N.." = "elseif type(N)=='string'then n=n.."[\""..N.."\"] = "else n=n.."["..tostring(N).."] = "end;if type(o)=='string'then n=n.."\""..o.."\""elseif type(o)=='number'then n=n..o elseif type(o)=='table'then n=n..J(o,L+(m and 1 or 0))else n=n..tostring(o)end;if next(l,N)then n=n..","end;if m then n=n..'\n'end end end;n=n.. (m and string.rep('    ',L)or'').."}"return n end;local function k(l)if l:match("\n")then local L={}for m in l:gmatch("[^\n]*")do table.insert(L,m)end;assert(#L>0)return L else return{l}end end;local function K(l,...)return print(string.format(l,...))end;return{PrintTable=J,CountTable=j,lookupify=I,splitLines=k,printf=K}end;F[4]=function()local I=f()F[4]=function()return I end;return I end end;do local f=function()local I=F[4]()local j=I.lookupify;local J=j{' ','\n','\t','\r'}local k={['\r']='\\r',['\n']='\\n',['\t']='\\t',['"']='\\"',["'"]="\\'"}local K=j{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}local l=j{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}local L=j{'0','1','2','3','4','5','6','7','8','9'}local m=j{'0','1','2','3','4','5','6','7','8','9','A','a','B','b','C','c','D','d','E','e','F','f'}local M=j{',','{','}','[',']','(',')',';','#'}local n=F[5]()local N=j{'and','continue','break','do','else','elseif','end','false','for','function','goto','if','in','local','nil','not','or','repeat','return','then','true','until','while'}local function o(p)local P={}local q,Q=pcall(function()local S=1;local t=1;local T=1;local function u()local W=p:sub(S,S)if W=='\n'then T=1;t=t+1 else T=T+1 end;S=S+1;return W end;local function U(W)W=W or 0;return p:sub(S+W,S+W)end;local function v(W)local x=U()for X=1,#W do if x==W:sub(X,X)then return u()end end end;local function V(W)return error(">> :"..t..":"..T..": "..W,0)end;local function w()local W=S;if U()=='['then local x=0;local X=1;while U(x+1)=='='do x=x+1 end;if U(x+1)=='['then for Z=0,x+1 do u()end;local y=S;while true do if U()==''then V("Expected `]"..string.rep('=',x).."]` near <eof>.",3)end;local Z=true;if U()==']'then for _=1,x do if U(_)~='='then Z=false end end;if U(x+1)~=']'then Z=false end else if U()=='['then local _=true;for aa=1,x do if U(aa)~='='then _=false;break end end;if U(x+1)=='['and _ then X=X+1;for aa=1,(x+2)do u()end end end;Z=false end;if Z then X=X-1;if X==0 then break else for _=1,x+2 do u()end end else u()end end;local Y=p:sub(y,S-1)for Z=0,x+1 do u()end;local z=p:sub(W,S-1)return Y,z else return nil end else return nil end end;while true do local W={}local x=''local X=false;while true do local aa=U()if aa=='#'and U(1)=='!'and t==1 then u()u()x="#!"while U()~='\n'and U()~=''do x=x..u()end;local aA={Type='Comment',CommentType='Shebang',Data=x,Line=t,Char=T}aA.Print=function()return"<".. (aA.Type..string.rep(' ',7-#aA.Type)).."  ".. (aA.Data or'').." >"end;x=""table.insert(W,aA)end;if aa==' 'or aa=='\t'then local aA=u()table.insert(W,{Type='Whitespace',Line=t,Char=T,Data=aA})elseif aa=='\n'or aa=='\r'then local aA=u()if x~=""then local ab={Type='Comment',CommentType=X and'LongComment'or'Comment',Data=x,Line=t,Char=T}ab.Print=function()return"<".. (ab.Type..string.rep(' ',7-#ab.Type)).."  ".. (ab.Data or'').." >"end;table.insert(W,ab)x=""end;table.insert(W,{Type='Whitespace',Line=t,Char=T,Data=aA})elseif aa=='-'and U(1)=='-'then u()u()x=x..'--'local aA,ab=w()if ab then x=x..ab;X=true else while U()~='\n'and U()~=''do x=x..u()end end else break end end;if x~=""then local aa={Type='Comment',CommentType=X and'LongComment'or'Comment',Data=x,Line=t,Char=T}aa.Print=function()return"<".. (aa.Type..string.rep(' ',7-#aa.Type)).."  ".. (aa.Data or'').." >"end;table.insert(W,aa)end;local y=t;local Y=T;local z=":"..t..":"..T..":> "local Z=U()local _=nil;if Z==''then _={Type='Eof'}elseif l[Z]or K[Z]or Z=='_'then local aa=S;repeat u()Z=U()until not(l[Z]or K[Z]or L[Z]or Z=='_')local aA=p:sub(aa,S-1)if N[aA]then _={Type='Keyword',Data=aA}else _={Type='Ident',Data=aA}end elseif L[Z]or(U()=='.'and L[U(1)])then local aa=S;if Z=='0'and U(1)=='x'then u()u()while m[U()]do u()end;if v('Pp')then v('+-')while L[U()]do u()end end else while L[U()]do u()end;if v('.')then while L[U()]do u()end end;if v('Ee')then v('+-')while L[U()]do u()end end end;_={Type='Number',Data=p:sub(aa,S-1)}elseif Z=='\''or Z=='\"'then local aa=S;local aA=u()local ab=S;while true do local Z=u()if Z=='\\'then u()elseif Z==aA then break elseif Z==''then V("Unfinished string near <eof>")end end;local aB=p:sub(ab,S-2)local ac=p:sub(aa,S-1)_={Type='String',Data=ac,Constant=aB}elseif Z=='['then local aa,aA=w()if aA then _={Type='String',Data=aA,Constant=aa}else u()_={Type='Symbol',Data='['}end elseif v('>=<')then if v('=')then _={Type='Symbol',Data=Z..'='}else _={Type='Symbol',Data=Z}end elseif v('~')then if v('=')then _={Type='Symbol',Data='~='}else V("Unexpected symbol `~` in source.",2)end elseif v('.')then if v('.')then if v('.')then _={Type='Symbol',Data='...'}else _={Type='Symbol',Data='..'}end else _={Type='Symbol',Data='.'}end elseif v(':')then if v(':')then _={Type='Symbol',Data='::'}else _={Type='Symbol',Data=':'}end elseif Z=='+'or Z=='-'or Z=='*'or Z=='/'or Z=='%'or Z=='^'then local aa=u()if U()=='='then u()_={Type='Symbol',Data=aa..'='}else _={Type='Symbol',Data=aa}end elseif M[Z]then u()_={Type='Symbol',Data=Z}else local aa,aA=w()if aa then _={Type='String',Data=aA,Constant=aa}else V("Unexpected Symbol `"..Z.."` in source.",2)end end;_.LeadingWhite=W;_.Line=y;_.Char=Y;_.Print=function()return"<".. (_.Type..string.rep(' ',7-#_.Type)).."  ".. (_.Data or'').." >"end;P[#P+1]=_;if _.Type=='Eof'then break end end end)if not q then return false,Q end;local r={}local R={}local s=1;function r:getp()return s end;function r:setp(S)s=S end;function r:getTokenList()return P end;function r:Peek(S)S=S or 0;return P[math.min(#P,s+S)]end;function r:Get(S)local t=P[s]s=math.min(s+1,#P)if S then table.insert(S,t)end;return t end;function r:Is(S)return r:Peek().Type==S end;function r:Save()R[#R+1]=s end;function r:Commit()R[#R]=nil end;function r:Restore()s=R[#R]R[#R]=nil end;function r:ConsumeSymbol(S,t)local T=self:Peek()if T.Type=='Symbol'then if S then if T.Data==S then self:Get(t)return true else return nil end else self:Get(t)return T end else return nil end end;function r:ConsumeKeyword(S,t)local T=self:Peek()if T.Type=='Keyword'and T.Data==S then self:Get(t)return true else return nil end end;function r:IsKeyword(S)local t=r:Peek()return t.Type=='Keyword'and t.Data==S end;function r:IsSymbol(S)local t=r:Peek()return t.Type=='Symbol'and t.Data==S end;function r:IsEof()return r:Peek().Type=='Eof'end;return true,r end;local function O(p)local R,s;if type(p)~='table'then R,s=o(p)else R,s=true,p end;if not R then return false,s end;local function S(r)local aa=">> :"..s:Peek().Line..":"..s:Peek().Char..": "..r.."\n"local aA=0;if type(p)=='string'then for ab in p:gmatch("[^\n]*\n?")do if ab:sub(-1,-1)=='\n'then ab=ab:sub(1,-2)end;aA=aA+1;if aA==s:Peek().Line then aa=aa..">> `"..ab:gsub('\t','    ').."`\n"for aB=1,s:Peek().Char do local ac=ab:sub(aB,aB)if ac=='\t'then aa=aa..'    'else aa=aa..' 'end end;aa=aa.."   ^^^^"break end end end;return aa end;local t=0;local T={'_','a','b','c','d'}local function u(r)local aa=n:new(r)aa.RenameVars=aa.ObfuscateLocals;aa.ObfuscateVariables=aa.ObfuscateLocals;aa.Print=function()return"<Scope>"end;return aa end;local U;local v;local V,w,W,x;local function X(r,aa)local aA=u(r)if not s:ConsumeSymbol('(',aa)then return false,S("`(` expected.")end;local ab={}local aB=false;while not s:ConsumeSymbol(')',aa)do if s:Is('Ident')then local ad=aA:CreateLocal(s:Get(aa).Data)ab[#ab+1]=ad;if not s:ConsumeSymbol(',',aa)then if s:ConsumeSymbol(')',aa)then break else return false,S("`)` expected.")end end elseif s:ConsumeSymbol('...',aa)then aB=true;if not s:ConsumeSymbol(')',aa)then return false,S("`...` must be the last argument of a function.")end;break else return false,S("Argument name or `...` expected")end end;local R,ac=v(aA)if not R then return false,ac end;if not s:ConsumeKeyword('end',aa)then return false,S("`end` expected after function body")end;local aC={}aC.AstType='Function'aC.Scope=aA;aC.Arguments=ab;aC.Body=ac;aC.VarArg=aB;aC.Tokens=aa;return true,aC end;function W(r)local aa={}if s:ConsumeSymbol('(',aa)then local R,aA=U(r)if not R then return false,aA end;if not s:ConsumeSymbol(')',aa)then return false,S("`)` Expected.")end;if false then aA.ParenCount=(aA.ParenCount or 0)+1;return true,aA else local ab={}ab.AstType='Parentheses'ab.Inner=aA;ab.Tokens=aa;return true,ab end elseif s:Is('Ident')then local aA=s:Get(aa)local ab=r:GetLocal(aA.Data)if not ab then ab=r:GetGlobal(aA.Data)if not ab then ab=r:CreateGlobal(aA.Data)else ab.References=ab.References+1 end else ab.References=ab.References+1 end;local aB={}aB.AstType='VarExpr'aB.Name=aA.Data;aB.Variable=ab;aB.Tokens=aa;return true,aB else return false,S("primary expression expected")end end;function x(r,aa)local R,aA=W(r)if not R then return false,aA end;while true do local ab={}if s:IsSymbol('.')or s:IsSymbol(':')then local aB=s:Get(ab).Data;if not s:Is('Ident')then return false,S("<Ident> expected.")end;local ac=s:Get(ab)local aC={}aC.AstType='MemberExpr'aC.Base=aA;aC.Indexer=aB;aC.Ident=ac;aC.Tokens=ab;aA=aC elseif not aa and s:ConsumeSymbol('[',ab)then local R,aB=U(r)if not R then return false,aB end;if not s:ConsumeSymbol(']',ab)then return false,S("`]` expected.")end;local ac={}ac.AstType='IndexExpr'ac.Base=aA;ac.Index=aB;ac.Tokens=ab;aA=ac elseif not aa and s:ConsumeSymbol('(',ab)then local aB={}while not s:ConsumeSymbol(')',ab)do local R,aC=U(r)if not R then return false,aC end;aB[#aB+1]=aC;if not s:ConsumeSymbol(',',ab)then if s:ConsumeSymbol(')',ab)then break else return false,S("`)` Expected.")end end end;local ac={}ac.AstType='CallExpr'ac.Base=aA;ac.Arguments=aB;ac.Tokens=ab;aA=ac elseif not aa and s:Is('String')then local aB={}aB.AstType='StringCallExpr'aB.Base=aA;aB.Arguments={s:Get(ab)}aB.Tokens=ab;aA=aB elseif not aa and s:IsSymbol('{')then local R,aB=V(r)if not R then return false,aB end;local ac={}ac.AstType='TableCallExpr'ac.Base=aA;ac.Arguments={aB}ac.Tokens=ab;aA=ac else break end end;return true,aA end;function V(r)local aa={}if s:Is('Number')then local aA={}aA.AstType='NumberExpr'aA.Value=s:Get(aa)aA.Tokens=aa;return true,aA elseif s:Is('String')then local aA={}aA.AstType='StringExpr'aA.Value=s:Get(aa)aA.Tokens=aa;return true,aA elseif s:ConsumeKeyword('nil',aa)then local aA={}aA.AstType='NilExpr'aA.Tokens=aa;return true,aA elseif s:IsKeyword('false')or s:IsKeyword('true')then local aA={}aA.AstType='BooleanExpr'aA.Value=(s:Get(aa).Data=='true')aA.Tokens=aa;return true,aA elseif s:ConsumeSymbol('...',aa)then local aA={}aA.AstType='DotsExpr'aA.Tokens=aa;return true,aA elseif s:ConsumeSymbol('{',aa)then local aA={}aA.AstType='ConstructorExpr'aA.EntryList={}while true do if s:IsSymbol('[',aa)then s:Get(aa)local R,ab=U(r)if not R then return false,S("Key Expression Expected")end;if not s:ConsumeSymbol(']',aa)then return false,S("`]` Expected")end;if not s:ConsumeSymbol('=',aa)then return false,S("`=` Expected")end;local R,aB=U(r)if not R then return false,S("Value Expression Expected")end;aA.EntryList[#aA.EntryList+1]={Type='Key',Key=ab,Value=aB}elseif s:Is('Ident')then local ab=s:Peek(1)if ab.Type=='Symbol'and ab.Data=='='then local aB=s:Get(aa)if not s:ConsumeSymbol('=',aa)then return false,S("`=` Expected")end;local R,ac=U(r)if not R then return false,S("Value Expression Expected")end;aA.EntryList[#aA.EntryList+1]={Type='KeyString',Key=aB.Data,Value=ac}else local R,aB=U(r)if not R then return false,S("Value Exected")end;aA.EntryList[#aA.EntryList+1]={Type='Value',Value=aB}end elseif s:ConsumeSymbol('}',aa)then break else local R,ab=U(r)aA.EntryList[#aA.EntryList+1]={Type='Value',Value=ab}if not R then return false,S("Value Expected")end end;if s:ConsumeSymbol(';',aa)or s:ConsumeSymbol(',',aa)then elseif s:ConsumeSymbol('}',aa)then break else return false,S("`}` or table entry Expected")end end;aA.Tokens=aa;return true,aA elseif s:ConsumeKeyword('function',aa)then local R,aA=X(r,aa)if not R then return false,aA end;aA.IsLocal=true;return true,aA elseif s:ConsumeKeyword('if',aa)then local aA,ab=U(r)if not aA then return false,ab end;if not s:ConsumeKeyword('then',aa)then return false,S("`then` expected in if-expression")end;local aB,ac=U(r)if not aB then return false,ac end;if not s:ConsumeKeyword('else',aa)then return false,S("`else` expected in if-expression")end;local aC,ad=U(r)if not aC then return false,ad end;local aD={}aD.AstType='IfExpression'aD.Condition=ab;aD.TrueExpression=ac;aD.FalseExpression=ad;aD.Tokens=aa;return true,aD else return x(r)end end;local y=j{'-','not','#'}local Y=j{'+=','-=','*=','/=','%=','^='}local z=8;local Z={['+']={6,6},['-']={6,6},['%']={7,7},['/']={7,7},['*']={7,7},['^']={10,9},['..']={5,4},['==']={3,3},['<']={3,3},['<=']={3,3},['~=']={3,3},['>']={3,3},['>=']={3,3},['and']={2,2},['or']={1,1}}function w(r,aa)local R,aA;if y[s:Peek().Data]then local ab={}local aB=s:Get(ab).Data;R,aA=w(r,z)if not R then return false,aA end;local ac={}ac.AstType='UnopExpr'ac.Rhs=aA;ac.Op=aB;ac.OperatorPrecedence=z;ac.Tokens=ab;aA=ac else R,aA=V(r)if not R then return false,aA end end;while true do local ab=Z[s:Peek().Data]if ab and ab[1]>aa then local aB={}local ac=s:Get(aB).Data;local R,aC=w(r,ab[2])if not R then return false,aC end;local ad={}ad.AstType='BinopExpr'ad.Lhs=aA;ad.Op=ac;ad.OperatorPrecedence=ab[1]ad.Rhs=aC;ad.Tokens=aB;aA=ad else break end end;return true,aA end;U=function(r)return w(r,0)end;local function _(r)local aa=nil;local aA={}if s:ConsumeKeyword('if',aA)then local ab={}ab.AstType='IfStatement'ab.Clauses={}repeat local R,aB=U(r)if not R then return false,aB end;if not s:ConsumeKeyword('then',aA)then return false,S("`then` expected.")end;local R,ac=v(r)if not R then return false,ac end;ab.Clauses[#ab.Clauses+1]={Condition=aB,Body=ac}until not s:ConsumeKeyword('elseif',aA)if s:ConsumeKeyword('else',aA)then local R,aB=v(r)if not R then return false,aB end;ab.Clauses[#ab.Clauses+1]={Body=aB}end;if not s:ConsumeKeyword('end',aA)then return false,S("`end` expected.")end;ab.Tokens=aA;aa=ab elseif s:ConsumeKeyword('while',aA)then local ab={}ab.AstType='WhileStatement'local R,aB=U(r)if not R then return false,aB end;if not s:ConsumeKeyword('do',aA)then return false,S("`do` expected.")end;local R,ac=v(r)if not R then return false,ac end;if not s:ConsumeKeyword('end',aA)then return false,S("`end` expected.")end;ab.Condition=aB;ab.Body=ac;ab.Tokens=aA;aa=ab elseif s:ConsumeKeyword('do',aA)then local R,ab=v(r)if not R then return false,ab end;if not s:ConsumeKeyword('end',aA)then return false,S("`end` expected.")end;local aB={}aB.AstType='DoStatement'aB.Body=ab;aB.Tokens=aA;aa=aB elseif s:ConsumeKeyword('for',aA)then if not s:Is('Ident')then return false,S("<ident> expected.")end;local ab=s:Get(aA)if s:ConsumeSymbol('=',aA)then local aB=u(r)local ac=aB:CreateLocal(ab.Data)local R,aC=U(r)if not R then return false,aC end;if not s:ConsumeSymbol(',',aA)then return false,S("`,` Expected")end;local R,ad=U(r)if not R then return false,ad end;local R,aD;if s:ConsumeSymbol(',',aA)then R,aD=U(r)if not R then return false,aD end end;if not s:ConsumeKeyword('do',aA)then return false,S("`do` expected")end;local R,ae=v(aB)if not R then return false,ae end;if not s:ConsumeKeyword('end',aA)then return false,S("`end` expected")end;local aE={}aE.AstType='NumericForStatement'aE.Scope=aB;aE.Variable=ac;aE.Start=aC;aE.End=ad;aE.Step=aD;aE.Body=ae;aE.Tokens=aA;aa=aE else local aB=u(r)local ac={aB:CreateLocal(ab.Data)}while s:ConsumeSymbol(',',aA)do if not s:Is('Ident')then return false,S("for variable expected.")end;ac[#ac+1]=aB:CreateLocal(s:Get(aA).Data)end;if not s:ConsumeKeyword('in',aA)then return false,S("`in` expected.")end;local aC={}local R,ad=U(r)if not R then return false,ad end;aC[#aC+1]=ad;while s:ConsumeSymbol(',',aA)do local R,aE=U(r)if not R then return false,aE end;aC[#aC+1]=aE end;if not s:ConsumeKeyword('do',aA)then return false,S("`do` expected.")end;local R,aD=v(aB)if not R then return false,aD end;if not s:ConsumeKeyword('end',aA)then return false,S("`end` expected.")end;local ae={}ae.AstType='GenericForStatement'ae.Scope=aB;ae.VariableList=ac;ae.Generators=aC;ae.Body=aD;ae.Tokens=aA;aa=ae end elseif s:ConsumeKeyword('repeat',aA)then local R,ab=v(r)if not R then return false,ab end;if not s:ConsumeKeyword('until',aA)then return false,S("`until` expected.")end;local R,aB=U(ab.Scope)if not R then return false,aB end;local ac={}ac.AstType='RepeatStatement'ac.Condition=aB;ac.Body=ab;ac.Tokens=aA;aa=ac elseif s:ConsumeKeyword('function',aA)then if not s:Is('Ident')then return false,S("Function name expected")end;local R,ab=x(r,true)if not R then return false,ab end;local R,aB=X(r,aA)if not R then return false,aB end;aB.IsLocal=false;aB.Name=ab;aa=aB elseif s:ConsumeKeyword('local',aA)then if s:Is('Ident')then local ab={s:Get(aA).Data}while s:ConsumeSymbol(',',aA)do if not s:Is('Ident')then return false,S("local var name expected")end;ab[#ab+1]=s:Get(aA).Data end;local aB={}if s:ConsumeSymbol('=',aA)then repeat local R,aC=U(r)if not R then return false,aC end;aB[#aB+1]=aC until not s:ConsumeSymbol(',',aA)end;for aC,ad in pairs(ab)do ab[aC]=r:CreateLocal(ad)end;local ac={}ac.AstType='LocalStatement'ac.LocalList=ab;ac.InitList=aB;ac.Tokens=aA;aa=ac elseif s:ConsumeKeyword('function',aA)then if not s:Is('Ident')then return false,S("Function name expected")end;local ab=s:Get(aA).Data;local aB=r:CreateLocal(ab)local R,ac=X(r,aA)if not R then return false,ac end;ac.Name=aB;ac.IsLocal=true;aa=ac else return false,S("local var or function def expected")end elseif s:ConsumeSymbol('::',aA)then if not s:Is('Ident')then return false,S('Label name expected')end;local ab=s:Get(aA).Data;if not s:ConsumeSymbol('::',aA)then return false,S("`::` expected")end;local aB={}aB.AstType='LabelStatement'aB.Label=ab;aB.Tokens=aA;aa=aB elseif s:ConsumeKeyword('return',aA)then local ab={}if not s:IsKeyword('end')then local R,ac=U(r)if R then ab[1]=ac;while s:ConsumeSymbol(',',aA)do local R,aC=U(r)if not R then return false,aC end;ab[#ab+1]=aC end end end;local aB={}aB.AstType='ReturnStatement'aB.Arguments=ab;aB.Tokens=aA;aa=aB elseif s:ConsumeKeyword('continue',aA)then local ab={}ab.AstType='ContinueStatement'ab.Tokens=aA;aa=ab elseif s:ConsumeKeyword('break',aA)then local ab={}ab.AstType='BreakStatement'ab.Tokens=aA;aa=ab elseif s:ConsumeKeyword('goto',aA)then if not s:Is('Ident')then return false,S("Label expected")end;local ab=s:Get(aA).Data;local aB={}aB.AstType='GotoStatement'aB.Label=ab;aB.Tokens=aA;aa=aB else local R,ab=x(r)if not R then return false,ab end;local aB=s:Peek()if Y[aB.Data]then local ac=s:Get(aA).Data;if(ab.ParenCount or 0)>0 then return false,S("Cannot assign to a parenthesized expression.")end;local aC,ad=U(r)if not aC then return false,ad end;local aD={}aD.AstType='SpecialAssignmentStatement'aD.Lhs=ab;aD.Operator=ac;aD.Rhs=ad;aD.Tokens=aA;aa=aD elseif s:IsSymbol(',')or s:IsSymbol('=')then if(ab.ParenCount or 0)>0 then return false,S("Can not assign to parenthesized expression, is not an lvalue")end;local ac={ab}while s:ConsumeSymbol(',',aA)do local R,ae=x(r)if not R then return false,ae end;ac[#ac+1]=ae end;if not s:ConsumeSymbol('=',aA)then return false,S("`=` Expected.")end;local aC={}local R,ad=U(r)if not R then return false,ad end;aC[1]=ad;while s:ConsumeSymbol(',',aA)do local R,ae=U(r)if not R then return false,ae end;aC[#aC+1]=ae end;local aD={}aD.AstType='AssignmentStatement'aD.Lhs=ac;aD.Rhs=aC;aD.Tokens=aA;aa=aD elseif ab.AstType=='CallExpr'or ab.AstType=='TableCallExpr'or ab.AstType=='StringCallExpr'then local ac={}ac.AstType='CallStatement'ac.Expression=ab;ac.Tokens=aA;aa=ac else return false,S("Assignment Statement Expected")end end;if s:IsSymbol(';')then aa.Semicolon=s:Get(aa.Tokens)end;return true,aa end;local P=j{'end','else','elseif','until'}v=function(r)local aa={}aa.Scope=u(r)aa.AstType='Statlist'aa.Body={}aa.Tokens={}while not P[s:Peek().Data]and not s:IsEof()do local R,aA=_(aa.Scope)if not R then return false,aA end;aa.Body[#aa.Body+1]=aA end;if s:IsEof()then local aA={}aA.AstType='Eof'aA.Tokens={s:Get()}aa.Body[#aa.Body+1]=aA end;return true,aa end;local function q()local r=u()return v(r)end;local R,Q=q()return R,Q end;return{LexLua=o,ParseLua=O}end;F[1]=function()local I=f()F[1]=function()return I end;return I end end;do local f=function()local I={new=function(j,J)local k={Parent=J,Locals={},Globals={},oldLocalNamesMap={},oldGlobalNamesMap={},Children={}}if J then table.insert(J.Children,k)end;return setmetatable(k,{__index=j})end,AddLocal=function(j,J)table.insert(j.Locals,J)end,AddGlobal=function(j,J)table.insert(j.Globals,J)end,CreateLocal=function(j,J)local k;k=j:GetLocal(J)if k then return k end;k={}k.Scope=j;k.Name=J;k.IsGlobal=false;k.CanRename=true;k.References=1;j:AddLocal(k)return k end,GetLocal=function(j,J)for k,K in pairs(j.Locals)do if K.Name==J then return K end end;if j.Parent then return j.Parent:GetLocal(J)end end,GetOldLocal=function(j,J)if j.oldLocalNamesMap[J]then return j.oldLocalNamesMap[J]end;return j:GetLocal(J)end,mapLocal=function(j,J,k)j.oldLocalNamesMap[J]=k end,GetOldGlobal=function(j,J)if j.oldGlobalNamesMap[J]then return j.oldGlobalNamesMap[J]end;return j:GetGlobal(J)end,mapGlobal=function(j,J,k)j.oldGlobalNamesMap[J]=k end,GetOldVariable=function(j,J)return j:GetOldLocal(J)or j:GetOldGlobal(J)end,RenameLocal=function(j,J,k)J=type(J)=='string'and J or J.Name;local K=false;local l=j:GetLocal(J)if l then l.Name=k;j:mapLocal(J,l)K=true end;if not K and j.Parent then j.Parent:RenameLocal(J,k)end end,RenameGlobal=function(j,J,k)J=type(J)=='string'and J or J.Name;local K=false;local l=j:GetGlobal(J)if l then l.Name=k;j:mapGlobal(J,l)K=true end;if not K and j.Parent then j.Parent:RenameGlobal(J,k)end end,RenameVariable=function(j,J,k)J=type(J)=='string'and J or J.Name;if j:GetLocal(J)then j:RenameLocal(J,k)else j:RenameGlobal(J,k)end end,GetAllVariables=function(j)local J=j:getVars(true)for k,K in pairs(j:getVars(false))do table.insert(J,K)end;return J end,getVars=function(j,J)local k={}if J then for K,l in pairs(j.Children)do for L,m in pairs(l:getVars(true))do table.insert(k,m)end end else for K,l in pairs(j.Locals)do table.insert(k,l)end;for K,l in pairs(j.Globals)do table.insert(k,l)end;if j.Parent then for K,l in pairs(j.Parent:getVars(false))do table.insert(k,l)end end end;return k end,CreateGlobal=function(j,J)local k;k=j:GetGlobal(J)if k then return k end;k={}k.Scope=j;k.Name=J;k.IsGlobal=true;k.CanRename=true;k.References=1;j:AddGlobal(k)return k end,GetGlobal=function(j,J)for k,K in pairs(j.Globals)do if K.Name==J then return K end end;if j.Parent then return j.Parent:GetGlobal(J)end end,GetVariable=function(j,J)return j:GetLocal(J)or j:GetGlobal(J)end,ObfuscateLocals=function(j,J,k)J=J or 7;local K="aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ_"local l="0123456789"local L=K..l;for m,M in pairs(j.Locals)do local n="a"local N={1}local o=0;while j:GetVariable(n)do local O=#N>1 and#L or#K;N[#N]=N[#N]+1;for p=1,#N-1 do if N[p+1]>O then N[p]=N[p]+1;N[p+1]=1 end end;if N[1]>O then N[1]=1;table.insert(N,1)end;n=""for p=1,#N do n=n..L:sub(N[p],N[p])end end;j:RenameLocal(M.Name,n)end end}return I end;F[5]=function()local I=f()F[5]=function()return I end;return I end end;do local f=function()local I=F[1]()local j=I.ParseLua;local J=F[4]()local k=J.lookupify;local K=k{'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'}local l=k{'A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'}local L=k{'0','1','2','3','4','5','6','7','8','9'}local m=k{'+','-','*','/','^','%',',','{','}','[',']','(',')',';','#'}local function M(n)local N,o;local O=0;local function p(q,Q,r)r=r or' 'local R,s=q:sub(-1,-1),Q:sub(1,1)if l[R]or K[R]or R=='_'then if not(l[s]or K[s]or s=='_'or L[s])then return q..Q elseif s=='('then return q..r..Q else return q..r..Q end elseif L[R]then if s=='('then return q..Q elseif m[s]then return q..Q else return q..r..Q end elseif R==''then return q..Q else if s=='('and not m[R]then return q..r..Q else return q..Q end end end;o=function(q,Q)local Q=Q or 0;local r=0;local R=false;local s=""if q.AstType=='VarExpr'then if q.Variable then s=s..q.Variable.Name else s=s..q.Name end elseif q.AstType=='NumberExpr'then s=s..q.Value.Data elseif q.AstType=='StringExpr'then s=s..q.Value.Data elseif q.AstType=='BooleanExpr'then s=s..tostring(q.Value)elseif q.AstType=='NilExpr'then s=p(s,"nil")elseif q.AstType=='BinopExpr'then r=q.OperatorPrecedence;s=p(s,o(q.Lhs,r))s=p(s,q.Op)s=p(s,o(q.Rhs))if q.Op=='^'or q.Op=='..'then r=r-1 end;if r<Q then R=false else R=true end elseif q.AstType=='UnopExpr'then s=p(s,q.Op)s=p(s,o(q.Rhs))elseif q.AstType=='DotsExpr'then s=s.."..."elseif q.AstType=='CallExpr'then s=s..o(q.Base)s=s.."("for S=1,#q.Arguments do s=s..o(q.Arguments[S])if S~=#q.Arguments then s=s..","end end;s=s..")"elseif q.AstType=='TableCallExpr'then s=s..o(q.Base)s=s..o(q.Arguments[1])elseif q.AstType=='StringCallExpr'then s=s..o(q.Base)s=s..q.Arguments[1].Data elseif q.AstType=='IndexExpr'then s=s..o(q.Base).."["..o(q.Index).."]"elseif q.AstType=='MemberExpr'then s=s..o(q.Base)..q.Indexer..q.Ident.Data elseif q.AstType=='Function'then q.Scope:ObfuscateVariables()s=s.."function("if#q.Arguments>0 then for S=1,#q.Arguments do s=s..q.Arguments[S].Name;if S~=#q.Arguments then s=s..","elseif q.VarArg then s=s..",..."end end elseif q.VarArg then s=s.."..."end;s=s..")"s=p(s,N(q.Body))s=p(s,"end")elseif q.AstType=='ConstructorExpr'then s=s.."{"for S=1,#q.EntryList do local t=q.EntryList[S]if t.Type=='Key'then s=s.."["..o(t.Key).."]="..o(t.Value)elseif t.Type=='Value'then s=s..o(t.Value)elseif t.Type=='KeyString'then s=s..t.Key.."="..o(t.Value)end;if S~=#q.EntryList then s=s..","end end;s=s.."}"elseif q.AstType=='IfExpression'then local S=o(q.Condition)local t=o(q.TrueExpression)local T=o(q.FalseExpression)s="(if "..S.." then "..t.." else "..T..")"elseif q.AstType=='Parentheses'then s=s.."("..o(q.Inner)..")"end;if not R then s=string.rep('(',q.ParenCount or 0)..s;s=s..string.rep(')',q.ParenCount or 0)end;O=O+#s;return s end;local P=function(q)local Q=''if q.AstType=='AssignmentStatement'then for r=1,#q.Lhs do Q=Q..o(q.Lhs[r])if r~=#q.Lhs then Q=Q..","end end;if#q.Rhs>0 then Q=Q.."="for r=1,#q.Rhs do Q=Q..o(q.Rhs[r])if r~=#q.Rhs then Q=Q..","end end end elseif q.AstType=='SpecialAssignmentStatement'then Q=Q..o(q.Lhs)Q=Q..q.Operator;Q=Q..o(q.Rhs)elseif q.AstType=='CallStatement'then Q=o(q.Expression)elseif q.AstType=='LocalStatement'then Q=Q.."local "for r=1,#q.LocalList do Q=Q..q.LocalList[r].Name;if r~=#q.LocalList then Q=Q..","end end;if#q.InitList>0 then Q=Q.."="for r=1,#q.InitList do Q=Q..o(q.InitList[r])if r~=#q.InitList then Q=Q..","end end end elseif q.AstType=='IfStatement'then Q=p("if",o(q.Clauses[1].Condition))Q=p(Q,"then")Q=p(Q,N(q.Clauses[1].Body))for r=2,#q.Clauses do local R=q.Clauses[r]if R.Condition then Q=p(Q,"elseif")Q=p(Q,o(R.Condition))Q=p(Q,"then")else Q=p(Q,"else")end;Q=p(Q,N(R.Body))end;Q=p(Q,"end")elseif q.AstType=='WhileStatement'then Q=p("while",o(q.Condition))Q=p(Q,"do")Q=p(Q,N(q.Body))Q=p(Q,"end")elseif q.AstType=='DoStatement'then Q=p(Q,"do")Q=p(Q,N(q.Body))Q=p(Q,"end")elseif q.AstType=='ReturnStatement'then Q="return"for r=1,#q.Arguments do Q=p(Q,o(q.Arguments[r]))if r~=#q.Arguments then Q=Q..","end end elseif q.AstType=='ContinueStatement'then Q="continue"elseif q.AstType=='BreakStatement'then Q="break"elseif q.AstType=='RepeatStatement'then Q="repeat"Q=p(Q,N(q.Body))Q=p(Q,"until")Q=p(Q,o(q.Condition))elseif q.AstType=='Function'then q.Scope:ObfuscateVariables()if q.IsLocal then Q="local"end;Q=p(Q,"function ")if q.IsLocal then Q=Q..q.Name.Name else Q=Q..o(q.Name)end;Q=Q.."("if#q.Arguments>0 then for r=1,#q.Arguments do Q=Q..q.Arguments[r].Name;if r~=#q.Arguments then Q=Q..","elseif q.VarArg then Q=Q..",..."end end elseif q.VarArg then Q=Q.."..."end;Q=Q..")"Q=p(Q,N(q.Body))Q=p(Q,"end")elseif q.AstType=='GenericForStatement'then q.Scope:ObfuscateVariables()Q="for "for r=1,#q.VariableList do Q=Q..q.VariableList[r].Name;if r~=#q.VariableList then Q=Q..","end end;Q=Q.." in"for r=1,#q.Generators do Q=p(Q,o(q.Generators[r]))if r~=#q.Generators then Q=p(Q,',')end end;Q=p(Q,"do")Q=p(Q,N(q.Body))Q=p(Q,"end")elseif q.AstType=='NumericForStatement'then q.Scope:ObfuscateVariables()Q="for "Q=Q..q.Variable.Name.."="Q=Q..o(q.Start)..","..o(q.End)if q.Step then Q=Q..","..o(q.Step)end;Q=p(Q,"do")Q=p(Q,N(q.Body))Q=p(Q,"end")elseif q.AstType=='LabelStatement'then Q=getIndentation().."::"..q.Label.."::"elseif q.AstType=='GotoStatement'then Q=getIndentation().."goto "..q.Label elseif q.AstType=='Comment'then elseif q.AstType=='Eof'then else print("Unknown AST Type: "..q.AstType)end;O=O+#Q;return Q end;N=function(q)local Q=''q.Scope:ObfuscateVariables()for r,R in pairs(q.Body)do Q=p(Q,P(R),';')end;return Q end;n.Scope:ObfuscateVariables()return N(n)end;return M end;F[2]=function()local I=f()F[2]=function()return I end;return I end end;local g=F[1]()local i=F[2]()local G=g.ParseLua;local h=F[3]()local H={}local function a(f)return f:match("(.*/)")or"./"end;local function A(f)f=f:gsub("\\","/")f=f:gsub("//","/")local j={}for I in f:gmatch("[^/]+")do if I==".."then table.remove(j)elseif I~="."then table.insert(j,I)end end;return table.concat(j,"/")end;local function b(f,j)j=j and(j:match("/$")and j or j.."/")or""local I={f,j..f,j..f..".lua",j..f..".luau",j..f:gsub("%.","/"),j..f:gsub("%.","/")..".lua",j..f:gsub("%.","/")..".luau",j..f:sub(1,1)..f:sub(2):gsub("%.","/"),j..f:sub(1,1)..f:sub(2):gsub("%.","/")..".lua",j..f:sub(1,1)..f:sub(2):gsub("%.","/")..".luau"}for J,k in ipairs(I)do local K=io.open(k,"r")if K then local L=K:read("*all")K:close()return L,k end end;return nil end;local function B(f)local j={f..".lua",f..".luau",f:gsub("%.","/"),f:gsub("%.","/")..".lua",f:gsub("%.","/")..".luau",f:sub(1,1)..f:sub(2):gsub("%.","/"),f:sub(1,1)..f:sub(2):gsub("%.","/")..".lua",f:sub(1,1)..f:sub(2):gsub("%.","/")..".luau"}for I=1,#j do local J=j[I]local k=io.open(J,"r")if k~=nil then k:close()return J end end end;function H.bundle(f,L,m,M,I,j,J,k,K)for o,p in next,K do f=f:gsub(o,function()return p end)end;f=H.minifyLua(f)L=L or L==nil;m=m or nil;I=I or{}j=j or{}local l={}k=k or 1;J=J==nil and"__MODULES_"..H.makeid(25)or J;local function n(o)local function p(O)local Q;local r,R=pcall(function()Q=B(M..O)end)if not r or not Q then return("require\"%s\""):format(O)end;local P=I[Q]or k;if not I[Q]then I[Q]=k;k=k+1 end;if m then l[m]=l[m]or{}table.insert(l[m],O)end;return J.."["..P.."]()"end;o=o:gsub('require%s*[%(%s]*([%\'"%[])(.-)%1[%)%s]*',function(O,q)return p(q)end)return o end;local N=n(f)for o,p in pairs(I)do if not j[o]then local O=b(o,M)if O then j[o]=O;local q=H.bundle(O,false,o,M,I,j,J,k,K)j[o]=q else print("WARNING: Failed to read module "..o)end end end;if L then local o=string.format([[
local %s = {}
]],J)for O,p in pairs(I)do o=o..string.format([[
do
    local module = function()
        %s
    end
    %s[%d] = function()
        local ret = module()
        %s[%d] = function() return ret end
        return ret
    end
end
]],j[O],J,p,J,p)end;N=o..N end;return N end;function H.makeid(f)local J="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_"local k="0123456789"local K=""local I=true;for j=1,f do local l=I and J or(J..k)local L=math.random(#l)K=K..l:sub(L,L)I=false end;return K end;function H.removeComments(f)f=f:gsub("%-%-.-\n","\n")f=f:gsub("%-%-%[%[.-%]%]","")return f end;function H.minifyLua(f,j)local I,k=G(f)if not I then error(k)return end;if j~=nil and j~="none"then k=h(k,j=="auto")end;return i(k)end;function H.writeFile(f,j)local I=io.open(f,"w")if not I then return false end;I:write(j)I:close()return true end;function H.main(f,j,J,k)f=f or"main.lua"j=j or"bundled.min.lua"local I,l=b(f)if not I then print("ERROR: Cannot read "..f)return false end;I=H.minifyLua(I)local L=H.bundle(I,true,nil,a(l),nil,nil,nil,nil,J)local m=H.minifyLua(L,k)if H.writeFile(j,m)then print("Bundling and minification completed successfully.")return true else print("Failed to write "..j)return false end end;math.randomseed(os.time())local c={...}if#c<1 then error("Usage: bundle.lua [entrypoint] [?-o output]")end;local C=c[1]local d=""do local f={}for j in C:gmatch("([^.]+)")do table.insert(f,j)end;if#f>1 and f[#f]=="lua"then table.remove(f,#f)end;d=table.concat(f,".")end;local D=d..".min.lua"local e={}local E="none"for f=2,#c-1 do if c[f]:lower()=="-o"then D=c[f+1]f=f+1 elseif c[f]:lower()=="-d"then local I,j=c[f+1]:match("(%w+)%s*=%s*(.-)%s*$")if type(I)=="string"and type(j)=="string"then e[I]=j end elseif c[f]:lower()=="-mangle"then E="mangle"elseif c[f]:lower()=="-automangle"then E="auto"end end;H.main(C,D,e,E)